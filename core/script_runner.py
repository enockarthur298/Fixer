#!/usr/bin/env python3
"""
Script Runner for Fixer AI

Safely executes repair scripts generated by the AI.
Implements security measures and sandboxing to prevent harmful operations.
"""

import os
import sys
import subprocess
import tempfile
import re
import time
from typing import List, Dict, Any, Optional, Tuple
import platform
import psutil

from utils import logger

# Initialize logger
log = logger.get_logger(__name__)

# Create temp directory for scripts if it doesn't exist
TEMP_DIR = os.path.join(tempfile.gettempdir(), "fixer_ai")
os.makedirs(TEMP_DIR, exist_ok=True)

# Define dangerous commands that should be blocked
DANGEROUS_COMMANDS = [
    # File system operations
    r"rm\s+-rf\s+/",  # Delete root
    r"rm\s+-rf\s+[~$]",  # Delete home or current directory
    r"del\s+/[Ff]\s+/[Qq]\s+[A-Za-z]:\\\*\.\*",  # Windows delete all
    r"format\s+[A-Za-z]:",  # Format drive
    
    # Network operations
    r"wget\s+.+\s+\|\s+bash",  # Download and execute
    r"curl\s+.+\s+\|\s+(ba)?sh",  # Download and execute
    
    # System operations
    r"shutdown\s+",  # Shutdown
    r"reboot\s+",  # Reboot
    r":(){ :|:& };:",  # Fork bomb
    
    # Dangerous PowerShell commands
    r"Remove-Item\s+-Recurse\s+-Force\s+[A-Za-z]:\\\*",  # Delete all files
    r"Invoke-Expression\s+\(New-Object\s+Net.WebClient\)\.DownloadString",  # Download and execute
]

def is_dangerous_script(script: str) -> Tuple[bool, str]:
    """Check if a script contains dangerous commands.
    
    Args:
        script: The script content to check
        
    Returns:
        Tuple of (is_dangerous, reason)
    """
    # Check for dangerous commands
    for pattern in DANGEROUS_COMMANDS:
        match = re.search(pattern, script, re.IGNORECASE)
        if match:
            return True, f"Dangerous command detected: {match.group(0)}"
    
    # Check for suspicious operations
    if "sudo rm" in script.lower():
        return True, "Suspicious sudo rm command detected"
    
    if "system32" in script.lower() and ("del" in script.lower() or "remove" in script.lower()):
        return True, "Attempt to delete system files detected"
    
    return False, ""

def save_script_to_file(script: str, script_type: str = "powershell") -> Optional[str]:
    """Save a script to a temporary file.
    
    Args:
        script: The script content
        script_type: The type of script (powershell, bash, batch)
        
    Returns:
        Path to the saved script file or None if failed
    """
    try:
        # Determine file extension based on script type
        extension = ".ps1" if script_type == "powershell" else ".bat" if script_type == "batch" else ".sh"
        
        # Create a temporary file
        timestamp = int(time.time())
        script_path = os.path.join(TEMP_DIR, f"repair_script_{timestamp}{extension}")
        
        # Write the script to the file
        with open(script_path, "w") as f:
            f.write(script)
        
        log.info(f"Script saved to {script_path}")
        return script_path
    
    except Exception as e:
        log.error(f"Error saving script to file: {e}")
        return None

def run_script(script: str, script_type: str = None) -> Tuple[str, Optional[str]]:
    """Run a repair script safely.
    
    Args:
        script: The script content to run
        script_type: Optional forced script type (powershell, batch, bash)
    
    Returns:
        Tuple of (output from the script execution, suggested retry type if error)
    """
    try:
        # Check if the script is dangerous
        is_dangerous, reason = is_dangerous_script(script)
        if is_dangerous:
            log.warning(f"Dangerous script detected: {reason}")
            return f"Error: Cannot execute script. {reason}", None
        
        # Determine the script type and save it to a file
        os_type = platform.system().lower()
        if script_type is None:
            if os_type == "windows":
                # Check if it's a PowerShell script
                if "function" in script or "param(" in script or "$" in script:
                    script_path = save_script_to_file(script, "powershell")
                    command = ["powershell", "-ExecutionPolicy", "Bypass", "-File", script_path]
                else:
                    script_path = save_script_to_file(script, "batch")
                    command = ["cmd", "/c", script_path]
            else:
                script_path = save_script_to_file(script, "bash")
                command = ["bash", script_path]
        else:
            script_path = save_script_to_file(script, script_type)
            if script_type == "powershell":
                command = ["powershell", "-ExecutionPolicy", "Bypass", "-File", script_path]
            elif script_type == "batch":
                command = ["cmd", "/c", script_path]
            else:
                command = ["bash", script_path]
        
        if not script_path:
            return "Error: Failed to save script to file", None
        
        # Execute the script with resource limits
        log.info(f"Executing script: {script_path}")
        
        # Set timeout for script execution (5 minutes)
        timeout = 300
        
        # Run the script and capture output
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        try:
            stdout, stderr = process.communicate(timeout=timeout)
            
            # Check return code
            if process.returncode != 0:
                log.warning(f"Script execution failed with return code {process.returncode}")
                error_msg = f"Error (code {process.returncode}):\n{stderr}\n\nOutput:\n{stdout}"
                # Check if this looks like a script type mismatch
                if os_type == "windows" and ".ps1" in script_path and ("@echo" in stderr or "Unexpected token 'off'" in stderr):
                    error_msg += "\n\nPossible script type mismatch: This appears to be a Batch script saved as PowerShell. Retry with correct type."
                    return error_msg, "batch"
                elif os_type == "windows" and ".bat" in script_path and ("command not recognized" in stderr or "not recognized as an internal or external command" in stderr):
                    error_msg += "\n\nPossible script type mismatch: This appears to be a PowerShell script saved as Batch. Retry with correct type."
                    return error_msg, "powershell"
                return error_msg, None
            
            log.info("Script executed successfully")
            return f"Success! Output:\n{stdout}", None
        except subprocess.TimeoutExpired:
            # Kill the process if it times out
            process.kill()
            log.warning("Script execution timed out")
            return "Error: Script execution timed out (5 minutes)", None
        finally:
            # Clean up old scripts after execution
            cleanup_old_scripts()
    
    except Exception as e:
        log.error(f"Error running script: {e}")
        return f"Error: {str(e)}", None

def cleanup_old_scripts(max_age_hours: int = 24) -> None:
    """Clean up old script files from the temp directory.
    
    Args:
        max_age_hours: Maximum age of scripts to keep in hours
    """
    try:
        current_time = time.time()
        max_age_seconds = max_age_hours * 3600
        
        for filename in os.listdir(TEMP_DIR):
            if filename.startswith("repair_script_"):
                file_path = os.path.join(TEMP_DIR, filename)
                if os.path.isfile(file_path):
                    file_age = current_time - os.path.getmtime(file_path)
                    if file_age > max_age_seconds:
                        os.remove(file_path)
                        log.info(f"Removed old script: {file_path}")
    
    except Exception as e:
        log.error(f"Error cleaning up old scripts: {e}")

# Example usage
if __name__ == "__main__":
    # Test script runner with a simple script
    test_script = """echo "Hello from Fixer AI!"
    echo "System Information:"
    systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
    """
    
    print(run_script(test_script))
    cleanup_old_scripts()
